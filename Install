#!/bin/bash
# =====================================================================
# ShowOn Script Manager V.1.0.5 (Full, consolidated installer)
# Author: TspKchn
# Maintainer: You
# =====================================================================
# This single-file installer:
#  - Provides a menu to Install / Uninstall / Update / View Debug Log
#  - Installs nginx site serving /server/ at port :82
#  - Generates online_app.json (SSH/OpenVPN/Dropbear/V2Ray) every 5s
#  - Supports V2Ray via:
#       * 3x-ui (new/old) using /panel/api/inbounds/onlines or fallbacks
#       * Xray-core with access logs (two common layouts)
#  - Generates sysinfo.json every 5s
#  - Optional netinfo.json using vnstat and/or 3x-ui server/status
#  - No password hiding on prompt (your request)
#  - Uninstall is clean, no reboot required
#  - Update pulls latest Install from your GitHub raw link
#
# Notes:
#  * Designed for Ubuntu/Debian
#  * Requires root
#  * Heavily commented for clarity; safe to edit.
# =====================================================================

# -----------------------------
# Global Config
# -----------------------------
VERSION="V.1.0.5"
REPO_RAW="https://raw.githubusercontent.com/TspKchn/showon/refs/heads/main/Install"

SHOWON_CMD="/usr/local/bin/showon"
CONF_FILE="/etc/showon.conf"
LOG_FILE="/var/log/showon-debug.log"

WWW_DIR="/var/www/html/server"
SCRIPT_ONLINE="/usr/local/bin/online-check.sh"
SCRIPT_SYSINFO="/usr/local/bin/sysinfo.sh"

SERVICE_ONLINE="/etc/systemd/system/online-check.service"
SERVICE_SYSINFO="/etc/systemd/system/sysinfo.service"

NGX_SITE_AVAIL="/etc/nginx/sites-available/server_checker"
NGX_SITE_ENABLED="/etc/nginx/sites-enabled/server_checker"

# -----------------------------
# Pretty Colors
# -----------------------------
GREEN="\e[32m"; RED="\e[31m"; YELLOW="\e[33m"; CYAN="\e[36m"; MAGENTA="\e[35m"; NC="\e[0m"

# -----------------------------
# Helpers
# -----------------------------
must_root() {
  if [[ $EUID -ne 0 ]]; then
    echo -e "${RED}[ERROR]${NC} Please run as root."
    exit 1
  fi
}

say() { echo -e "${CYAN}[INFO]${NC} $*"; }
ok()  { echo -e "${GREEN}[OK]${NC} $*"; }
warn(){ echo -e "${YELLOW}[WARN]${NC} $*"; }
err() { echo -e "${RED}[ERROR]${NC} $*"; }

timestamp() { date '+%Y-%m-%d %H:%M:%S'; }

append_log() {
  echo "[$(timestamp)] $*" >> "$LOG_FILE"
}

create_showon_cmd() {
  cat > "$SHOWON_CMD" <<'EOF'
#!/bin/bash
exec bash /root/Install
EOF
  chmod +x "$SHOWON_CMD"
}

print_footer_link() {
  local ip; ip=$(hostname -I 2>/dev/null | awk '{print $1}')
  [[ -z "$ip" ]] && ip="127.0.0.1"
  echo -e "${CYAN}[INFO]${NC} Open: http://${ip}:82/server/"
}

# -----------------------------
# Update Checker (on menu)
# -----------------------------
check_update() {
  local latest
  latest=$(curl -fsSL "$REPO_RAW" 2>/dev/null | grep -m1 '^VERSION=' | cut -d\" -f2 | tr -d '\r')
  if [[ -n "$latest" && "$latest" != "$VERSION" ]]; then
    echo -e "${YELLOW}[UPDATE AVAILABLE]${NC} Latest: ${latest} (Current: ${VERSION})"
    read -r -p "Press Enter to update now, or Ctrl+C to skip..." _
    if curl -fsSL -o /root/Install.new "$REPO_RAW"; then
      mv /root/Install.new /root/Install
      chmod +x /root/Install
      ok "Updated to ${latest}"
      echo -e "${CYAN}[INFO]${NC} Run 'showon' again to load the new version."
      exit 0
    else
      warn "Failed to download latest installer. Keeping current version."
    fi
  else
    ok "You are using the latest version."
  fi
}

# -----------------------------
# Nginx site writer
# -----------------------------
write_nginx_site() {
  mkdir -p "$WWW_DIR"
  cat >"$NGX_SITE_AVAIL" <<'EOF'
server {
    listen 82 default_server;
    server_name _;

    # Redirect root to /server/
    location = / {
        return 302 /server/;
    }

    # Serve /server/* from /var/www/html/server
    location /server/ {
        alias /var/www/html/server/;
        index index.html;
        autoindex on;
    }
}
EOF
  ln -sf "$NGX_SITE_AVAIL" "$NGX_SITE_ENABLED"
  nginx -t && systemctl reload nginx
  ok "Nginx ready at :82 (/server/)"
}

# -----------------------------
# Detect Environment
# -----------------------------
detect_env() {
  # 3x-ui typical marker
  if [[ -f /etc/x-ui/x-ui.db ]]; then
    echo "HAS_XUI_DB=1"
  fi
  if [[ -f /usr/local/etc/xray/config.json ]]; then
    echo "HAS_XRAY_LOCAL=1"
  fi
  if [[ -f /etc/xray/config.json ]]; then
    echo "HAS_XRAY_ETC=1"
  fi
}

# -----------------------------
# Ask & Validate 3x-ui login (URL, user, pass)
#  - URL must include scheme/host/port/basepath (copy from login page)
#  - No password hiding on input (your request)
#  - Try endpoints:
#       POST /panel/api/inbounds/onlines   (preferred new)
#       GET  /panel/api/inbounds/onlines   (some forks/custom)
#       Fallback: derive from /panel/api/inbounds/list + lastOnline window
# -----------------------------
ask_xui_and_validate() {
  echo -e "${CYAN}[INFO]${NC} ตั้งค่า 3x-ui (ถ้าไม่มีให้กด Enter ข้ามได้)"
  echo "  👉 กรุณา 'วางลิงก์หน้าล็อกอินทั้งเส้น' เช่น:"
  echo "     https://IP:PORT/SomeRandomPath  หรือ  http://domain:port/"
  read -r -p "3X-UI URL (copy login link): " XUI_URL
  XUI_URL="${XUI_URL%/}"
  if [[ -z "$XUI_URL" ]]; then
    warn "ข้ามการตั้งค่า 3x-ui (จะพยายามตรวจ Xray-core logs แทน)"
    return 1
  fi
  read -r -p "3X-UI Username: " XUI_USER
  read -r -p "3X-UI Password: " XUI_PASS

  # Login (cookie only)
  local COOKIE="/tmp/showon_cookie.$$"
  if ! curl -sk -c "$COOKIE" -X POST "${XUI_URL}/login" \
        -d "username=${XUI_USER}&password=${XUI_PASS}" >/dev/null; then
    err "ไม่สามารถเชื่อมต่อได้ (login)"
    rm -f "$COOKIE"
    return 2
  fi

  # Try preferred POST onlines
  local POST_OK=0
  local GET_OK=0
  local ONLINES_METHOD=""
  local ONLINES_PATH=""

  # POST
  local probe_post
  probe_post=$(curl -sk -b "$COOKIE" -H "Content-Type: application/json" \
                    -X POST "${XUI_URL}/panel/api/inbounds/onlines" \
                    -d "{}" 2>/dev/null)
  if echo "$probe_post" | jq -e '.success == true and (.obj|type=="array")' >/dev/null 2>&1; then
    POST_OK=1
    ONLINES_METHOD="POST"
    ONLINES_PATH="/panel/api/inbounds/onlines"
  else
    # Try GET
    local probe_get
    probe_get=$(curl -sk -b "$COOKIE" "${XUI_URL}/panel/api/inbounds/onlines" 2>/dev/null)
    if echo "$probe_get" | jq -e '.success == true and (.obj|type=="array")' >/dev/null 2>&1; then
      GET_OK=1
      ONLINES_METHOD="GET"
      ONLINES_PATH="/panel/api/inbounds/onlines"
    fi
  fi

  if [[ $POST_OK -eq 1 || $GET_OK -eq 1 ]]; then
    ok "Login to 3x-ui OK"
    # Save to conf
    cat > "$CONF_FILE" <<EOF
# --- ShowOn configuration ---
VERSION="${VERSION}"
WWW_DIR="${WWW_DIR}"
LIMIT="2000"
DEBUG_LOG="${LOG_FILE}"

# 3x-ui
PANEL_BASE="${XUI_URL}"
XUI_USER="${XUI_USER}"
XUI_PASS="${XUI_PASS}"
XUI_ONLINES_METHOD="${ONLINES_METHOD}"
XUI_ONLINES_PATH="${ONLINES_PATH}"
XUI_ONLINE_WINDOW_MS="60000"
EOF
    chmod 600 "$CONF_FILE"
    rm -f "$COOKIE"
    return 0
  fi

  # Fallback: use list + lastOnline heuristic
  local lst js_ok
  lst=$(curl -sk -b "$COOKIE" "${XUI_URL}/panel/api/inbounds/list")
  js_ok=0
  if echo "$lst" | jq -e '.success == true' >/dev/null 2>&1; then js_ok=1; fi
  if [[ $js_ok -eq 1 ]]; then
    ok "Login OK (fallback via inbounds/list)"
    cat > "$CONF_FILE" <<EOF
# --- ShowOn configuration ---
VERSION="${VERSION}"
WWW_DIR="${WWW_DIR}"
LIMIT="2000"
DEBUG_LOG="${LOG_FILE}"

# 3x-ui (fallback)
PANEL_BASE="${XUI_URL}"
XUI_USER="${XUI_USER}"
XUI_PASS="${XUI_PASS}"
XUI_ONLINES_METHOD="FALLBACK"
XUI_ONLINES_PATH="/panel/api/inbounds/list"
XUI_ONLINE_WINDOW_MS="60000"
EOF
    chmod 600 "$CONF_FILE"
    rm -f "$COOKIE"
    return 0
  fi

  rm -f "$COOKIE"
  err "ยืนยัน 3x-ui ไม่ผ่าน (login ok? endpoint เปลี่ยน?)"
  return 3
}

# -----------------------------
# Dependencies
# -----------------------------
install_dependencies() {
  say "Updating system packages..."
  apt update -y >/dev/null 2>&1 || true
  say "Installing dependencies..."
  apt install -y curl jq nginx net-tools psmisc iproute2 ca-certificates vnstat >/dev/null 2>&1
}

# -----------------------------
# Write Worker Scripts
# -----------------------------
write_worker_scripts() {
  # online-check.sh
  cat >"$SCRIPT_ONLINE" <<'EOF'
#!/bin/bash
set -euo pipefail
CONF="/etc/showon.conf"
[[ -f "$CONF" ]] && source "$CONF" || true

# Defaults
: "${VERSION:=V.1.0.5}"
: "${WWW_DIR:=/var/www/html/server}"
: "${LIMIT:=2000}"
: "${DEBUG_LOG:=/var/log/showon-debug.log}"
: "${PANEL_BASE:=}"
: "${XUI_USER:=}"
: "${XUI_PASS:=}"
: "${XUI_ONLINES_METHOD:=}"
: "${XUI_ONLINES_PATH:=}"
: "${XUI_ONLINE_WINDOW_MS:=60000}"

JSON_OUT="${WWW_DIR}/online_app.json"
mkdir -p "$WWW_DIR"

log() { echo "[$(date +'%F %T')][ONLINE] $*" >> "$DEBUG_LOG"; }

# Count SSH/OpenVPN/Dropbear
SSH_ON=$(ss -nt state established | awk '$3 ~ /:22$/ {c++} END{print c+0}')
OVPN_ON=0
if [[ -f /etc/openvpn/server/openvpn-status.log ]]; then
  OVPN_ON=$(grep -c "CLIENT_LIST" /etc/openvpn/server/openvpn-status.log || true)
fi
DB_ON=$(pgrep dropbear >/dev/null 2>&1 && pgrep dropbear | wc -l || echo 0)

# V2Ray (XUI or XRAY logs)
V2_ON=0

# Helper: fetch onlines via POST/GET
fetch_onlines_array() {
  local method="$1" path="$2"
  local cookie="/tmp/showon_cookie.online.$$"

  # login
  curl -sk -c "$cookie" -X POST "${PANEL_BASE}/login" \
       -d "username=${XUI_USER}&password=${XUI_PASS}" >/dev/null || true

  local res
  if [[ "$method" == "POST" ]]; then
    res=$(curl -sk -b "$cookie" -H "Content-Type: application/json" \
               -X POST "${PANEL_BASE}${path}" -d "{}" 2>/dev/null)
  else
    res=$(curl -sk -b "$cookie" "${PANEL_BASE}${path}" 2>/dev/null)
  fi

  rm -f "$cookie"
  echo "$res"
}

# Helper: count using list + lastOnline window
fetch_onlines_fallback() {
  local cookie="/tmp/showon_cookie.online.$$"
  curl -sk -c "$cookie" -X POST "${PANEL_BASE}/login" \
       -d "username=${XUI_USER}&password=${XUI_PASS}" >/dev/null || true

  local list last now
  list=$(curl -sk -b "$cookie" "${PANEL_BASE}/panel/api/inbounds/list" 2>/dev/null)
  last=$(curl -sk -b "$cookie" -H "Content-Type: application/json" \
             -X POST "${PANEL_BASE}/panel/api/inbounds/lastOnline" -d "{}" 2>/dev/null || echo '{}')
  now=$(date +%s%3N)
  rm -f "$cookie"

  # Build set of emails with (now - lastOnline) < window
  # result: count only those in last map and within time window
  jq -n --argjson lst "$list" --argjson last "$last" --argjson now "$now" \
        --argjson win "$XUI_ONLINE_WINDOW_MS" '
    def toMap: reduce .[] as $x ({}; .[$x.email]=$x);
    if ($lst.success==true and ($lst.obj|type)=="array") then
      ($lst.obj[]?.clientStats // []) as $cs
      | [ $cs[] | .email ] as $emails
      | ($last.obj // {}) as $m
      | [ $emails[] | select( ($m[.]//0) > 0 and ($now - ($m[.]//0)) < $win ) ]
      | unique
      | length
    else 0 end
  ' 2>/dev/null
}

# Determine V2_ON
if [[ -n "${PANEL_BASE}" && -n "${XUI_ONLINES_METHOD}" ]]; then
  if [[ "$XUI_ONLINES_METHOD" == "POST" || "$XUI_ONLINES_METHOD" == "GET" ]]; then
    resp="$(fetch_onlines_array "$XUI_ONLINES_METHOD" "$XUI_ONLINES_PATH")"
    V2_ON=$(echo "$resp" | jq -r 'if .success==true and (.obj|type)=="array" then (.obj|length) else 0 end' 2>/dev/null || echo 0)
  else
    # FALLBACK
    V2_ON=$(fetch_onlines_fallback 2>/dev/null || echo 0)
  fi
else
  # Try XRAY logs heuristics (best-effort)
  if [[ -f /var/log/xray/access.log ]]; then
    # deb package layout
    V2_ON=$(tail -n 2000 /var/log/xray/access.log 2>/dev/null | awk '/accepted/ {print $3}' | cut -d: -f1 | sort -u | wc -l)
  elif compgen -G "/var/log/xray/*log" >/dev/null; then
    V2_ON=$(grep -ha "accepted" /var/log/xray/*log 2>/dev/null | tail -n 2000 | awk '{print $3}' | cut -d: -f1 | sort -u | wc -l)
  else
    V2_ON=0
  fi
fi

TOTAL=$(( SSH_ON + OVPN_ON + DB_ON + V2_ON ))

JSON=$(jq -n \
  --arg onlines "$TOTAL" \
  --arg limite "${LIMIT}" \
  --arg ssh "${SSH_ON}" \
  --arg openvpn "${OVPN_ON}" \
  --arg dropbear "${DB_ON}" \
  --arg v2ray "${V2_ON}" \
  '[{onlines:($onlines|tonumber), limite:($limite|tonumber), ssh:($ssh|tonumber), openvpn:($openvpn|tonumber), dropbear:($dropbear|tonumber), v2ray:($v2ray|tonumber)}]')

echo "$JSON" > "$JSON_OUT"
log "online: $(echo "$JSON" | jq .)"
EOF
  chmod +x "$SCRIPT_ONLINE"

  # sysinfo.sh
  cat >"$SCRIPT_SYSINFO" <<'EOF'
#!/bin/bash
set -euo pipefail
CONF="/etc/showon.conf"
[[ -f "$CONF" ]] && source "$CONF" || true
: "${WWW_DIR:=/var/www/html/server}"
: "${DEBUG_LOG:=/var/log/showon-debug.log}"
OUT="${WWW_DIR}/sysinfo.json"
mkdir -p "$WWW_DIR"

log() { echo "[$(date +'%F %T')][SYS] $*" >> "$DEBUG_LOG"; }

uptime_h=$(uptime -p | sed 's/up //')
# CPU usage quick estimate
cpu_idle=$(top -bn1 | awk -F',' '/Cpu\(s\)/{print $4}' | awk '{print $1}' | sed 's/%//')
if [[ -z "$cpu_idle" ]]; then
  cpu_usage="N/A"
else
  cpu_usage=$(awk -v idle="${cpu_idle:-0}" 'BEGIN{printf "%.1f%%", 100-idle}')
fi
mem_line=$(free -m | awk 'NR==2{printf "%s / %s MB",$3,$2}')
disk_line=$(df -h / | awk 'NR==2{print $3" / "$2}')

jq -n --arg uptime "$uptime_h" --arg cpu "$cpu_usage" --arg ram "$mem_line" --arg disk "$disk_line" \
  '{uptime:$uptime, cpu_usage:$cpu, ram_usage:$ram, disk_usage:$disk}' > "$OUT"
log "sysinfo: $(cat "$OUT")"
EOF
  chmod +x "$SCRIPT_SYSINFO"
}

# -----------------------------
# Services
# -----------------------------
write_services_and_start() {
  cat >"$SERVICE_ONLINE" <<EOF
[Unit]
Description=ShowOn Online Users JSON Generator
After=network.target

[Service]
Type=simple
ExecStart=/bin/bash -lc 'while true; do "$SCRIPT_ONLINE"; sleep 5; done'
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF

  cat >"$SERVICE_SYSINFO" <<EOF
[Unit]
Description=ShowOn System Info JSON Generator
After=network.target

[Service]
Type=simple
ExecStart=/bin/bash -lc 'while true; do "$SCRIPT_SYSINFO"; sleep 5; done'
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF

  systemctl daemon-reload
  systemctl enable --now online-check.service
  systemctl enable --now sysinfo.service
}

# -----------------------------
# Index HTML
# -----------------------------
write_index_html() {
  mkdir -p "$WWW_DIR"
  cat >"$WWW_DIR/index.html" <<EOF
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>ShowOn Dashboard ${VERSION}</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body { background:#0e0e0e; color:#eaeaea; font-family:system-ui, Arial, sans-serif; margin:0; padding:24px; }
  h1 { color:#4ff585; margin:0 0 16px 0; }
  .grid { display:grid; gap:16px; grid-template-columns: 1fr; max-width:900px; }
  .card { background:#1a1a1a; border:1px solid #2a2a2a; border-radius:12px; padding:16px; }
  table { width:100%; border-collapse:collapse; }
  th, td { border:1px solid #2b2b2b; padding:8px; text-align:center; }
  th { background:#202020; }
  .muted { color:#9aa0a6; font-size:12px; }
  .ok { color:#4ff585; }
  .bad { color:#ff6b6b; }
  .spinner {border:4px solid #333;border-top:4px solid #4ff585;border-radius:50%;width:18px;height:18px;animation:spin 1s linear infinite;margin:auto;}
  @keyframes spin {100% {transform: rotate(360deg);}}
  @media (min-width: 900px){ .grid{ grid-template-columns: 1fr 1fr; } }
</style>
</head>
<body>
  <h1>ShowOn Dashboard <span class="muted">${VERSION}</span></h1>
  <div class="grid">
    <div class="card">
      <h2>Online Summary</h2>
      <table>
        <thead>
          <tr><th>Onlines</th><th>Limit</th><th>SSH</th><th>OpenVPN</th><th>Dropbear</th><th>V2Ray</th></tr>
        </thead>
        <tbody>
          <tr id="summary"><td colspan="6"><div class="spinner"></div></td></tr>
        </tbody>
      </table>
      <p class="muted" id="status"></p>
    </div>
    <div class="card">
      <h2>System &amp; Network</h2>
      <div id="system"><div class="spinner"></div></div>
    </div>
  </div>

<script>
async function refresh() {
  try {
    const r1 = await fetch('./online_app.json?_=' + Date.now());
    const a1 = await r1.json();
    const d = a1[0];
    document.getElementById('summary').innerHTML =
      '<td>' + d.onlines + '</td>' +
      '<td>' + d.limite  + '</td>' +
      '<td>' + d.ssh     + '</td>' +
      '<td>' + d.openvpn + '</td>' +
      '<td>' + d.dropbear+ '</td>' +
      '<td>' + d.v2ray   + '</td>';
    document.getElementById('status').textContent = 'Updated ' + new Date().toLocaleTimeString();
  } catch(e) {
    document.getElementById('summary').innerHTML = '<td colspan="6" class="bad">Error loading online_app.json</td>';
  }

  try {
    const r2 = await fetch('./sysinfo.json?_=' + Date.now());
    const s = await r2.json();
    document.getElementById('system').innerHTML =
      '<b>Uptime:</b> ' + s.uptime + '<br>' +
      '<b>CPU:</b> '    + s.cpu_usage + '<br>' +
      '<b>RAM:</b> '    + s.ram_usage + '<br>' +
      '<b>Disk:</b> '   + s.disk_usage;
  } catch(e) {
    document.getElementById('system').innerHTML = '<span class="bad">Error loading sysinfo.json</span>';
  }
}
refresh(); setInterval(refresh, 5000);
</script>
</body>
</html>
EOF
  chmod 644 "$WWW_DIR/index.html"
}

# -----------------------------
# Menu Actions
# -----------------------------
install_script() {
  say "Installing ShowOn (${VERSION})..."
  install_dependencies
  write_nginx_site

  # Ask 3x-ui (optional) and validate
  local configured=0
  if ask_xui_and_validate; then
    configured=1
  fi

  # Limit user online
  if [[ $configured -eq 1 ]]; then
    read -r -p "Limit User Online (Default: 2000): " LIMIN
    LIMIN=${LIMIN:-2000}
    # patch LIMIT in conf
    sed -i "s/^LIMIT=.*/LIMIT=\"${LIMIN}\"/" "$CONF_FILE"
  else
    # Ensure minimal conf exists
    [[ -f "$CONF_FILE" ]] || cat >"$CONF_FILE" <<EOF
VERSION="${VERSION}"
WWW_DIR="${WWW_DIR}"
LIMIT="2000"
DEBUG_LOG="${LOG_FILE}"
EOF
  fi

  write_worker_scripts
  write_services_and_start
  write_index_html
  ok "Installed ShowOn ${VERSION}"
  print_footer_link
  read -r -p "Press Enter to return to menu..." _
}

uninstall_script() {
  echo -e "${YELLOW}[INFO]${NC} Uninstalling ShowOn Script..."
  systemctl stop online-check.service sysinfo.service 2>/dev/null || true
  systemctl disable online-check.service sysinfo.service 2>/dev/null || true
  rm -f "$SERVICE_ONLINE" "$SERVICE_SYSINFO"
  rm -f "$SCRIPT_ONLINE" "$SCRIPT_SYSINFO"
  rm -f "$CONF_FILE"
  rm -rf "$WWW_DIR"
  rm -f "$NGX_SITE_AVAIL" "$NGX_SITE_ENABLED"
  systemctl daemon-reload
  systemctl reload nginx 2>/dev/null || systemctl restart nginx 2>/dev/null || true
  ok "Uninstalled completely (no reboot required)."
  read -r -p "Press Enter to return to menu..." _
}

update_script() {
  echo -e "${CYAN}[INFO]${NC} Checking for updates..."
  check_update
  read -r -p "Press Enter to return to menu..." _
}

show_debug_log() {
  echo -e "${CYAN}[INFO]${NC} Tail -50 ${LOG_FILE}"
  touch "$LOG_FILE"
  tail -n 50 "$LOG_FILE"
  echo
  read -r -p "Press Enter to return to menu..." _
}

# -----------------------------
# Menu UI
# -----------------------------
show_menu() {
  clear
  echo -e "==============================="
  echo -e "   ShowOn Script Manager ${VERSION}"
  echo -e "==============================="
  check_update
  echo "1) Install Script"
  echo "2) Uninstall Script"
  echo "3) Update Script"
  echo "4) Check Debug Log"
  echo "0) Exit"
  echo "==============================="
  read -r -p "Choose an option [0,1,2,3,4]: " choice
  case "$choice" in
    1) install_script ;;
    2) uninstall_script ;;
    3) update_script ;;
    4) show_debug_log ;;
    0) exit 0 ;;
    *) err "Invalid choice"; sleep 1 ;;
  esac
  show_menu
}

# -----------------------------
# Bootstrap
# -----------------------------
must_root
create_showon_cmd
show_menu
